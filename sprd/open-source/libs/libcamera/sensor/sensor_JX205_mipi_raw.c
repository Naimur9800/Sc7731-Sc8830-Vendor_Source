/* * Copyright (C) 2012 The Android Open Source Project *    * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */#include <utils/Log.h>#include "sensor.h"#include "jpeg_exif_header.h"#include "sensor_drv_u.h"#include "sensor_raw.h"#include "sensor_JX205_raw_param.c"//add comment#define JX205_PID_VALUE    0x02#define JX205_PID_ADDR     0x0a#define JX205_VER_VALUE    0x05#define JX205_VER_ADDR     0x0b#define JX205_I2C_ADDR_W        	0x30  //0x60#define JX205_I2C_ADDR_R         	0x30#define JX205_RAW_PARAM_COM  		0x0000#define JX205_MAX_SHUTTER_OFFSET 	3#define JX205_GROUP_WRITE_EN		1//1#define JX205_FLIP_EN			1//1#define JX205_MIRROR_EN			1//1#define JX205_USE_VERTICAL_BINNING_EN 	1//1#define JX205_800x600_RESOLUTION_ONLY	0//0//#define JX205_2_LANESstatic int s_JX205_capture_shutter = 0;static int s_JX205_capture_VTS = 0;static int s_JX205_video_min_framerate = 0;static int s_JX205_video_max_framerate = 0;#define LOG_TAG "SOI"LOCAL unsigned long _JX205_GetResolutionTrimTab(unsigned long param);LOCAL unsigned long _JX205_PowerOn(unsigned long power_on);LOCAL unsigned long _JX205_Identify(unsigned long param);LOCAL unsigned long _JX205_BeforeSnapshot(unsigned long param);LOCAL unsigned long _JX205_after_snapshot(unsigned long param);LOCAL unsigned long _JX205_StreamOn(unsigned long param);LOCAL unsigned long _JX205_StreamOff(unsigned long param);LOCAL unsigned long _JX205_write_exposure(unsigned long param);LOCAL unsigned long _JX205_write_gain(unsigned long param);LOCAL unsigned long _JX205_SetEV(unsigned long param);LOCAL unsigned long _JX205_flash(unsigned long param);LOCAL unsigned long _JX205_ExtFunc(unsigned long ctl_param);LOCAL int _JX205_get_VTS(void);LOCAL int _JX205_set_VTS(int VTS);LOCAL unsigned long _JX205_ReadGain(unsigned long param);LOCAL unsigned long _JX205_set_video_mode(unsigned long param);LOCAL int _JX205_get_shutter(void);LOCAL uint32_t _JX205_com_Identify_otp(void* param_ptr);static uint32_t s_JX205_gain = 0;static uint32_t g_module_id = 0;static uint32_t g_flash_mode_en = 0;LOCAL const struct raw_param_info_tab s_JX205_raw_param_tab[]={	{JX205_RAW_PARAM_COM, &s_JX205_mipi_raw_info, _JX205_com_Identify_otp, PNULL},	{RAW_INFO_END_ID, PNULL, PNULL, PNULL}};struct sensor_raw_info* s_JX205_raw_info_ptr=NULL;LOCAL const SENSOR_REG_T JX205_com_raw[] ={	{0xc0, 0x00},//0x00}, // gain};LOCAL const SENSOR_REG_T JX205_1600X1200_raw[] = {   	//;;Output Detail:	//;;MCLK:24 MHz	//;;PCLK:38.4	//;;Mipi PCLK:38.4	//;;VCO:384	//;;FrameW:1796	//;;FrameH:1426	// line time : 46.77 us	//    {0x12,0x40},//;;---Sleep Mode   	{0x12,(0x40 | (JX205_MIRROR_EN << 5) |(JX205_FLIP_EN << 4))},	//{0x0D, 0x00}, //0xF0},	{0x0D, 0xA0}, // 0510: steven test	{0x1F, 0x00},	{0x0E, 0x1D},	{0x0F, 0x09},	{0x10, 0x20},	{0x11, 0x80},	{0x20, 0x04},	{0x21, 0x07},	{0x22, 0x92},	{0x23, 0x05},	{0x24, 0x40},	{0x25, 0xB0},	{0x26, 0x46},	{0x27, 0xBE},	{0x28, 0x0D},	{0x29, 0x00},	//{0x2A, 0xAC},	{0x2A, 0xAB}, // 0510: steven test	{0x2B, 0x50},	{0x2C, 0x02},	{0x2D, 0x00},	{0x2E, 0x30},	{0x2F, 0x04},	{0x60, 0x47},	{0x68, 0x04},	{0x13, 0x81},//87	{0x14, 0x80},	{0x16, 0xC0},	{0x17, 0x40},	{0x18, 0xB2},	{0x19, 0x80},	{0x37, 0x2D},	{0x38, 0xFF},	{0x39, 0x70},	{0x4A, 0x03},//0x0D},	{0x49, 0x10},//0x04},	{0x1D, 0x00},	{0x1E, 0x00},	{0x6C, 0x10},	{0x70, 0x49},	{0x72, 0x28},	{0x73, 0x33},	{0x74, 0x78},	{0x75, 0x2B},	{0x76, 0xD0},	{0x77, 0x07},	{0x78, 0x15},};LOCAL const SENSOR_REG_T JX205_800X600_raw[] = {	//;;Output Detail:	//;;MCLK:24 MHz	//;;PCLK:38.4	//;;Mipi PCLK:38.4	//;;VCO:384	//;;FrameW:1166	//;;FrameH:1098   	// line time : 30.36 us       	{0x12,(0x41 | (JX205_MIRROR_EN << 5) |(JX205_FLIP_EN << 4) | (JX205_USE_VERTICAL_BINNING_EN << 1))},	{0x0D, 0xF0}, //00x00}, //0xF0},	{0x1F, 0x00},	{0x0E, 0x1D},	{0x0F, 0x09},	{0x10, 0x20},	{0x11, 0x80},	{0x20, 0x8E},	{0x21, 0x04},	{0x22, 0x4A},	{0x23, 0x04},	{0x24, 0x20},	{0x25, 0x58},	{0x26, 0x23},	{0x27, 0x68},	{0x28, 0x07},	{0x29, 0x01},	{0x2A, 0x57 + JX205_MIRROR_EN*4},//0x58 + JX205_MIRROR_EN*4},//0x58},	{0x2B, 0x51},	{0x2C, 0x02},	{0x2D, 0x00},	{0x2E, 0x31 - JX205_FLIP_EN}, //0x31},	{0x2F, 0x04},	{0x60, 0x47},	{0x68, 0x04},	{0x13, 0x81},//87	{0x14, 0x80},	{0x16, 0xC0},	{0x17, 0x40},	{0x18, 0x12},	{0x19, 0x81},	{0x37, 0x63},	{0x38, 0xD4},	{0x39, 0x38},	{0x4A, 0x03},//0x0D},	{0x49, 0x10},//0x04},	{0x1D, 0x00},	{0x1E, 0x00},	{0x6C, 0x10},	{0x70, 0x49},	{0x72, 0x28},	{0x73, 0x33},	{0x74, 0x78},	{0x75, 0x2B},	{0x76, 0xE8},	{0x77, 0x03},	{0x78, 0x15},};LOCAL SENSOR_REG_TAB_INFO_T s_JX205_resolution_Tab_RAW[] = {	{ADDR_AND_LEN_OF_ARRAY(JX205_com_raw), 0, 0, 24, SENSOR_IMAGE_FORMAT_RAW},	{ADDR_AND_LEN_OF_ARRAY(JX205_1600X1200_raw), 1600,  1200, 24, SENSOR_IMAGE_FORMAT_RAW},	{PNULL, 0, 0, 0, 0, 0},	{PNULL, 0, 0, 0, 0, 0},	{PNULL, 0, 0, 0, 0, 0},	{PNULL, 0, 0, 0, 0, 0},	{PNULL, 0, 0, 0, 0, 0},	{PNULL, 0, 0, 0, 0, 0},	{PNULL, 0, 0, 0, 0, 0}};LOCAL SENSOR_TRIM_T s_JX205_Resolution_Trim_Tab[] = {	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 1600,  1200, 467, 384, 1426, {0, 0,  1600,  1200}},//sysclk*10	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}}};LOCAL const SENSOR_REG_T s_JX205_800x600_video_tab[SENSOR_VIDEO_MODE_MAX][1] = {	/*video mode 0: ?fps*/	{		{0xffff, 0xff}	},	/* video mode 1:?fps*/	{		{0xffff, 0xff}	},	/* video mode 2:?fps*/	{		{0xffff, 0xff}	},	/* video mode 3:?fps*/	{		{0xffff, 0xff}	}};LOCAL const SENSOR_REG_T s_JX205_1600x1200_video_tab[SENSOR_VIDEO_MODE_MAX][1] = {	/*video mode 0: ?fps*/	{		{0xffff, 0xff}	},	/* video mode 1:?fps*/	{		{0xffff, 0xff}	},	/* video mode 2:?fps*/	{		{0xffff, 0xff}	},	/* video mode 3:?fps*/	{		{0xffff, 0xff}	}};LOCAL SENSOR_VIDEO_INFO_T s_JX205_video_info[] = {	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{15, 15, 467, 100}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},(SENSOR_REG_T**)s_JX205_1600x1200_video_tab},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL}};LOCAL unsigned long _JX205_set_video_mode(unsigned long param){	SENSOR_REG_T_PTR sensor_reg_ptr;	uint16_t         i = 0x00;	uint32_t         mode;	if (param >= SENSOR_VIDEO_MODE_MAX)		return 0;	if (SENSOR_SUCCESS != Sensor_GetMode(&mode)) {		SENSOR_PRINT_HIGH("fail.");		return SENSOR_FAIL;	}	if (PNULL == s_JX205_video_info[mode].setting_ptr) {		SENSOR_PRINT_HIGH("fail.");		return SENSOR_FAIL;	}	sensor_reg_ptr = (SENSOR_REG_T_PTR)&s_JX205_video_info[mode].setting_ptr[param];	if (PNULL == sensor_reg_ptr) {		SENSOR_PRINT_HIGH("fail.");		return SENSOR_FAIL;	}	for (i=0x00; (0xffff!=sensor_reg_ptr[i].reg_addr)||(0xff!=sensor_reg_ptr[i].reg_value); i++) {		Sensor_WriteReg(sensor_reg_ptr[i].reg_addr, sensor_reg_ptr[i].reg_value);	}	SENSOR_PRINT_HIGH("_JX205_set_video_mode = 0x%02x", param);	return 0;}LOCAL SENSOR_IOCTL_FUNC_TAB_T s_JX205_ioctl_func_tab = {	PNULL,	_JX205_PowerOn,	PNULL,	_JX205_Identify,	PNULL,// write register	PNULL,// read  register	PNULL,	_JX205_GetResolutionTrimTab,	// External	PNULL,	PNULL,	PNULL,	PNULL, //_JX205_set_brightness,	PNULL, // _JX205_set_contrast,	PNULL,	PNULL,//_JX205_set_saturation,	PNULL, //_JX205_set_work_mode,	PNULL, //_JX205_set_image_effect,	_JX205_BeforeSnapshot,	_JX205_after_snapshot,	PNULL, //_JX205_flash,	PNULL,	_JX205_write_exposure,	PNULL,	_JX205_write_gain,	PNULL,	PNULL,	PNULL,//_JX205_write_af,	PNULL,	PNULL, //_JX205_set_awb,	PNULL,	PNULL,	PNULL, //_JX205_set_ev,	PNULL,	PNULL,	PNULL,	PNULL, //_JX205_GetExifInfo,	PNULL, //_JX205_ExtFunc,	PNULL, //_JX205_set_anti_flicker,	PNULL, //_JX205_set_video_mode, //_JX205_set_video_mode,	PNULL, //pick_jpeg_stream	PNULL, //meter_mode	PNULL, //get_status	_JX205_StreamOn,	_JX205_StreamOff,	PNULL};SENSOR_INFO_T g_JX205_mipi_raw_info = {	JX205_I2C_ADDR_W,	// salve i2c write address	JX205_I2C_ADDR_R,	// salve i2c read address	SENSOR_I2C_REG_8BIT | SENSOR_I2C_REG_8BIT | SENSOR_I2C_FREQ_400,	// bit0: 0: i2c register value is 8 bit, 1: i2c register value is 16 bit	// bit1: 0: i2c register addr  is 8 bit, 1: i2c register addr  is 16 bit	// other bit: reseved	SENSOR_HW_SIGNAL_PCLK_N | SENSOR_HW_SIGNAL_VSYNC_N | SENSOR_HW_SIGNAL_HSYNC_N,	// bit0: 0:negative; 1:positive -> polarily of pixel clock	// bit2: 0:negative; 1:positive -> polarily of horizontal synchronization signal	// bit4: 0:negative; 1:positive -> polarily of vertical synchronization signal	// other bit: reseved	// preview mode	SENSOR_ENVIROMENT_NORMAL | SENSOR_ENVIROMENT_NIGHT,	// image effect	SENSOR_IMAGE_EFFECT_NORMAL |	    SENSOR_IMAGE_EFFECT_BLACKWHITE |	    SENSOR_IMAGE_EFFECT_RED |	    SENSOR_IMAGE_EFFECT_GREEN |	    SENSOR_IMAGE_EFFECT_BLUE |	    SENSOR_IMAGE_EFFECT_YELLOW |	    SENSOR_IMAGE_EFFECT_NEGATIVE | SENSOR_IMAGE_EFFECT_CANVAS,	// while balance mode	0,	7,			// bit[0:7]: count of step in brightness, contrast, sharpness, saturation	// bit[8:31] reseved	SENSOR_LOW_PULSE_RESET,	// reset pulse level	50,			// reset pulse width(ms)	SENSOR_LOW_LEVEL_PWDN,	// 1: high level valid; 0: low level valid	1,			// count of identify code	{{JX205_PID_ADDR, JX205_PID_VALUE},		// supply two code to identify sensor.	 {JX205_VER_ADDR, JX205_VER_VALUE}},		// for Example: index = 0-> Device id, index = 1 -> version id	SENSOR_AVDD_2800MV,	// voltage of avdd SENSOR_AVDD_2800MV	1600,			// max width of source image	1200,			// max height of source image	"JX205",		// name of sensor	SENSOR_IMAGE_FORMAT_RAW,	// define in SENSOR_IMAGE_FORMAT_E enum,SENSOR_IMAGE_FORMAT_MAX	// if set to SENSOR_IMAGE_FORMAT_MAX here, image format depent on SENSOR_REG_TAB_INFO_T	SENSOR_IMAGE_PATTERN_RAWRGB_R,// pattern of input image form sensor; R	s_JX205_resolution_Tab_RAW,	// point to resolution table information structure	&s_JX205_ioctl_func_tab,	// point to ioctl function table	&s_JX205_raw_info_ptr,		// information and table about Rawrgb sensor	NULL,			//&g_JX205_ext_info,                // extend information about sensor	SENSOR_AVDD_1800MV,	// iovdd  SENSOR_AVDD_2800MV	SENSOR_AVDD_CLOSED,	// dvdd   SENSOR_AVDD_1800MV	3,			// skip frame num before preview	3,			// skip frame num before capture	0,			// deci frame num during preview	0,			// deci frame num during video preview	0,	0,	0,	0,	0,	{SENSOR_INTERFACE_TYPE_CSI2, 1, 10, 0},	s_JX205_video_info,	3,			// skip frame num while change setting};LOCAL struct sensor_raw_info* _Jx205_GetContext(void){	return s_JX205_raw_info_ptr;}LOCAL uint32_t _JX205_InitRawTuneInfo(void){	uint32_t rtn=0x00;	struct sensor_raw_info* raw_sensor_ptr=_Jx205_GetContext();	struct sensor_raw_tune_info* sensor_ptr=raw_sensor_ptr->tune_ptr;	struct sensor_raw_cali_info* cali_ptr=raw_sensor_ptr->cali_ptr;	raw_sensor_ptr->version_info->version_id=0x00010000;	raw_sensor_ptr->version_info->srtuct_size=sizeof(struct sensor_raw_info);	sensor_ptr->grgb.edge_thr= 0x3F;	sensor_ptr->cfa.edge_thr= 0x3F;	sensor_ptr->cfa.diff_thr= 0x03;	return rtn;}LOCAL unsigned long _JX205_GetResolutionTrimTab(unsigned long param){	SENSOR_PRINT_HIGH("SENSOR_JX205 GetResolutionTrimTab param = 0x%lx, param = 0x%lx", (unsigned long)s_JX205_Resolution_Trim_Tab, param);	return (unsigned long) s_JX205_Resolution_Trim_Tab;}LOCAL unsigned long _JX205_PowerOn(unsigned long power_on){	SENSOR_AVDD_VAL_E dvdd_val = g_JX205_mipi_raw_info.dvdd_val;	SENSOR_AVDD_VAL_E avdd_val = g_JX205_mipi_raw_info.avdd_val;	SENSOR_AVDD_VAL_E iovdd_val = g_JX205_mipi_raw_info.iovdd_val;	BOOLEAN power_down = g_JX205_mipi_raw_info.power_down_level;	BOOLEAN reset_level = g_JX205_mipi_raw_info.reset_pulse_level;	if (SENSOR_TRUE == power_on) {		Sensor_PowerDown(!power_down);		// Open power		Sensor_SetMonitorVoltage(SENSOR_AVDD_2800MV);		Sensor_SetVoltage(dvdd_val, avdd_val, iovdd_val);		usleep(20*1000);			Sensor_SetMCLK(SENSOR_DEFALUT_MCLK);		usleep(10*1000);		Sensor_PowerDown(power_down);		// Reset sensor		Sensor_Reset(reset_level);	} else {		Sensor_PowerDown(power_down);		Sensor_SetMCLK(SENSOR_DISABLE_MCLK);		Sensor_SetVoltage(SENSOR_AVDD_CLOSED, SENSOR_AVDD_CLOSED, SENSOR_AVDD_CLOSED);		Sensor_SetMonitorVoltage(SENSOR_AVDD_CLOSED);	}	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_Power_On(1:on, 0:off): %ld  ", power_on);	return SENSOR_SUCCESS;}LOCAL unsigned long _JX205_cfg_otp(unsigned long  param){	uint32_t rtn=SENSOR_SUCCESS;	struct raw_param_info_tab* tab_ptr = (struct raw_param_info_tab*)s_JX205_raw_param_tab;	uint32_t module_id=g_module_id;	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_cfg_otp");	if(PNULL!=tab_ptr[module_id].cfg_otp){		tab_ptr[module_id].cfg_otp(0);	}	return rtn;}LOCAL uint32_t _JX205_com_Identify_otp(void* param_ptr){	uint32_t rtn=SENSOR_FAIL;	uint32_t param_id;	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_com_Identify_otp");	/*read param id from sensor omap*/	param_id=JX205_RAW_PARAM_COM;	if(JX205_RAW_PARAM_COM==param_id){		rtn=SENSOR_SUCCESS;	}	return rtn;}LOCAL uint32_t _JX205_GetRawInof(void){	uint32_t rtn=SENSOR_SUCCESS;	struct raw_param_info_tab* tab_ptr = (struct raw_param_info_tab*)s_JX205_raw_param_tab;	uint32_t param_id;	uint32_t i=0x00;	/*read param id from sensor omap*/	param_id=JX205_RAW_PARAM_COM;	for(i=0x00; ; i++)	{		g_module_id = i;		if(RAW_INFO_END_ID==tab_ptr[i].param_id){			if(NULL==s_JX205_raw_info_ptr){				SENSOR_PRINT_HIGH("SENSOR_JX205: JX205_GetRawInof no param error");				rtn=SENSOR_FAIL;			}			SENSOR_PRINT_HIGH("SENSOR_JX205: JX205_GetRawInof end");			break;		} else if(PNULL!=tab_ptr[i].identify_otp){			if(SENSOR_SUCCESS==tab_ptr[i].identify_otp(0))			{				s_JX205_raw_info_ptr = tab_ptr[i].info_ptr;				SENSOR_PRINT_HIGH("SENSOR_JX205: JX205_GetRawInof success");				break;			}		}	}	return rtn;}LOCAL unsigned long _JX205_GetMaxFrameLine(unsigned long index){	uint32_t max_line=0x00;	SENSOR_TRIM_T_PTR trim_ptr=s_JX205_Resolution_Trim_Tab;	max_line=trim_ptr[index].frame_line;	return max_line;}LOCAL unsigned long _JX205_Identify(unsigned long param){	uint8_t pid_value = 0x00;	uint8_t ver_value = 0x00;	uint32_t ret_value = SENSOR_FAIL;	SENSOR_PRINT_HIGH("SENSOR_JX205:  raw identify \n");	pid_value = Sensor_ReadReg(JX205_PID_ADDR);	if (JX205_PID_VALUE == pid_value) {		ver_value = Sensor_ReadReg(JX205_VER_ADDR);		SENSOR_PRINT_HIGH("SENSOR_JX205: Identify: PID = %x, VER = %x", pid_value, ver_value);		if (JX205_VER_VALUE == ver_value) {			_JX205_GetRawInof();			_JX205_InitRawTuneInfo();			ret_value = SENSOR_SUCCESS;			SENSOR_PRINT_HIGH("SENSOR_JX205: this is JX205 sensor !");		} else {			SENSOR_PRINT			    ("SENSOR_JX205: Identify this is JX%x%x sensor !", pid_value, ver_value);		}	} else {		SENSOR_PRINT_ERR("SENSOR_JX205: identify fail,pid_value=%x", pid_value);	}	return ret_value;}LOCAL unsigned long _JX205_write_exposure(unsigned long param){	uint32_t ret_value = SENSOR_SUCCESS;	uint16_t expsure_line=0x00;	uint16_t size_index=0x00;	uint16_t frame_len=0x00;	uint16_t frame_len_cur=0x00;	uint16_t max_frame_len=0x00;	uint16_t value=0x00;	uint8_t lsb=0x00;	uint8_t msb=0x00;	expsure_line=param&0xffff;	size_index=(param>>0x1c)&0x0f;	if (!expsure_line) expsure_line = 1; 	max_frame_len =_JX205_GetMaxFrameLine(size_index);	if(0x00!=max_frame_len)	{		frame_len = ((expsure_line + JX205_MAX_SHUTTER_OFFSET)> max_frame_len) ? (expsure_line + JX205_MAX_SHUTTER_OFFSET) : max_frame_len;		if(0x00!=(0x01&frame_len))		{			frame_len+=0x01;		}		frame_len_cur = (Sensor_ReadReg(0x23)&0xff)<<8;		frame_len_cur |= Sensor_ReadReg(0x22)&0xff;		SENSOR_PRINT_HIGH("SENSOR_JX205: frame_len_cur = %d    frame_len = %d \n", frame_len_cur, frame_len);		if (frame_len_cur != frame_len){			lsb=(frame_len)&0xff;			msb=(frame_len>>0x08)&0xff;			ret_value = Sensor_WriteReg(0x22, lsb);			ret_value = Sensor_WriteReg(0x23, msb);		}		lsb=(expsure_line)&0xff;		msb=(expsure_line>>0x08)&0xff;		ret_value = Sensor_WriteReg(0x01, lsb);		ret_value = Sensor_WriteReg(0x02, msb);	}	SENSOR_PRINT_HIGH("SENSOR_JX205: JX205_Write_Shutter expsure_line = 0x%x, max_frame_len = 0x%x", expsure_line, max_frame_len);	return ret_value;}LOCAL unsigned long _JX205_write_gain(unsigned long param){	uint32_t ret_value = SENSOR_SUCCESS;	uint16_t val;	val = Sensor_ReadReg(0x12);	Sensor_WriteReg(0xc0, 0x00); // gain	Sensor_WriteReg(0xC1, (param & 0x7f)); 	Sensor_WriteReg(0x12, (val | 0x08));			SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_write_gain gain = 0x%lx", param);	return ret_value;}LOCAL unsigned long _JX205_BeforeSnapshot(unsigned long param){		uint8_t ret_l, ret_m, ret_h;	uint32_t capture_exposure, preview_maxline;	uint32_t capture_maxline, preview_exposure;	uint32_t capture_mode = param & 0xffff;	uint32_t preview_mode = (param >> 0x10 ) & 0xffff;	uint32_t prv_linetime = s_JX205_Resolution_Trim_Tab[preview_mode].line_time;	uint32_t cap_linetime = s_JX205_Resolution_Trim_Tab[capture_mode].line_time;	Sensor_SetMode(capture_mode);	Sensor_SetMode_WaitDone();	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_BeforeSnapshot preview_mode/capture_mode = 0x%x, 0x%x", preview_mode, capture_mode);	return SENSOR_SUCCESS;}LOCAL unsigned long _JX205_after_snapshot(unsigned long param){	uint8_t ret_l, ret_m, ret_h;	SENSOR_PRINT_HIGH("SENSOR_JX205: after_snapshot mode:%ld", param);	Sensor_SetMode((uint32_t)param);	return SENSOR_SUCCESS;}LOCAL unsigned long _JX205_flash(unsigned long param){	SENSOR_PRINT_HIGH("SENSOR_JX205: param=%d", param);	/* enable flash, disable in _JX205_BeforeSnapshot */	g_flash_mode_en = param;	Sensor_SetFlash(param);	SENSOR_PRINT_HIGH("end");	return SENSOR_SUCCESS;}LOCAL unsigned long _JX205_StreamOn(unsigned long param){	SENSOR_PRINT_HIGH("SENSOR_JX205: StreamOn");	int val;	val = Sensor_ReadReg(0x12);	val &= ~(0x40);	Sensor_WriteReg(0x12, val);	return 0;}LOCAL unsigned long _JX205_StreamOff(unsigned long param){	SENSOR_PRINT_HIGH("SENSOR_JX205: StreamOff");	int val;	val = Sensor_ReadReg(0x12);	val |= 0x40;	Sensor_WriteReg(0x12, val);	usleep(100*1000);	return 0;}int _JX205_get_shutter(void){	// read shutter, in number of line period	int shutter;	shutter = Sensor_ReadReg(0x01);	shutter = (shutter<<8) + Sensor_ReadReg(0x02);SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_get_shutter shutter = 0x%x", shutter);	return shutter;}int _JX205_set_shutter(int shutter){	// write shutter, in number of line period	int temp;	shutter = shutter & 0xffff;	temp = shutter & 0xff;		Sensor_WriteReg(0x01, temp);	temp = (shutter >> 8) & 0xff;		Sensor_WriteReg(0x02, temp);	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_set_shutter shutter = 0x%x", shutter);	return 0;}int _JX205_get_gain16(void){	// read gain, 16 = 1x	int gain16, param;	param = Sensor_ReadReg(0x00);	gain16 = ((param&0xf)+16)*(((param>>4)&0x01)+1)*(((param>>5)&0x01)+1)*(((param>>6)&0x01)+1);	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_get_gain16 gain16 = 0x%x", gain16);	return gain16;}int _JX205_set_gain16(int gain16){	// write gain, 16 = 1x	uint16_t iReg,temp;	uint16_t gainMSB, gainLSB;	//param : 1x = 16	if (16*16 < gain16)		gain16 = 255;	if (1*16 > gain16)		gain16 = 16;	if(8*16 <= gain16) {		gainMSB = 7;	} else if (4*16 <= gain16) {		gainMSB = 3;	} else if (2*16 <= gain16){		gainMSB = 1;	} else {		gainMSB = 0;	}		gainLSB = gain16 / (gainMSB + 1) - 16;	if (gainLSB > 15) 		gainLSB = 15;		Sensor_WriteReg(0x00, (gainMSB << 4) + gainLSB); 	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_set_gain16 gain16 = 0x%x, gainMSB,LSB = 0x%x,0x%x ", gain16,gainMSB,gainLSB);	return 0;}static void _calculate_hdr_exposure(int capture_gain16,int capture_VTS, int capture_shutter){	// write capture gain	_JX205_set_gain16(capture_gain16);	// write capture shutter	_JX205_set_shutter(capture_shutter);}LOCAL unsigned long _JX205_SetEV(unsigned long param){	uint32_t rtn = SENSOR_SUCCESS;	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) param;	uint16_t value=0x00;	uint32_t gain = s_JX205_gain;	uint32_t ev = ext_ptr->param;	SENSOR_PRINT_HIGH("SENSOR: _JX205_SetEV param: 0x%x", ev);	switch(ev) {	case SENSOR_HDR_EV_LEVE_0:		_calculate_hdr_exposure(s_JX205_gain/2,s_JX205_capture_VTS,s_JX205_capture_shutter);		break;	case SENSOR_HDR_EV_LEVE_1:		_calculate_hdr_exposure(s_JX205_gain,s_JX205_capture_VTS,s_JX205_capture_shutter);		break;	case SENSOR_HDR_EV_LEVE_2:		_calculate_hdr_exposure(s_JX205_gain,s_JX205_capture_VTS,s_JX205_capture_shutter *4);		break;	default:		break;	}	return rtn;}LOCAL unsigned long _JX205_ExtFunc(unsigned long ctl_param){	uint32_t rtn = SENSOR_SUCCESS;	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) ctl_param;	SENSOR_PRINT_HIGH("0x%x", ext_ptr->cmd);	switch (ext_ptr->cmd) {	case SENSOR_EXT_FUNC_INIT:		break;	case SENSOR_EXT_FOCUS_START:		break;	case SENSOR_EXT_EXPOSURE_START:		break;	case SENSOR_EXT_EV:		rtn = _JX205_SetEV(ctl_param);		break;	default:		break;	}	return rtn;}LOCAL int _JX205_get_VTS(void){	// read VTS from register settings	int VTS;	VTS = Sensor_ReadReg(0x23);//total vertical size[15:8] high byte	VTS = (VTS<<8) + Sensor_ReadReg(0x22);	return VTS;}LOCAL int _JX205_set_VTS(int VTS){	// write VTS to registers	int temp;	temp = VTS & 0xff;	Sensor_WriteReg(0x22, temp);	temp = VTS>>8;	Sensor_WriteReg(0x23, temp);	return 0;}LOCAL unsigned long _JX205_ReadGain(unsigned long param){	uint32_t rtn = SENSOR_SUCCESS;	uint16_t value=0x00;	uint32_t gain = 0;	value = Sensor_ReadReg(0x00);	s_JX205_gain=(int)value;	SENSOR_PRINT_HIGH("SENSOR_JX205: _JX205_ReadGain gain: 0x%x", s_JX205_gain);	return rtn;}