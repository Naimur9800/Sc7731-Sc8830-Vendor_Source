#define LOG_TAG 	"WCND"
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <cutils/sockets.h>
#include <ctype.h>
#include <pthread.h>
#include <errno.h>
#include <cutils/properties.h>
#include <utils/Log.h>
#include <signal.h>

#include <sys/capability.h>
#include <linux/prctl.h>
#include <private/android_filesystem_config.h>

#include "wcnd.h"
#include "wcnd_sm.h"
#include "wcnd_util.h"


bool is_zero_ether_addr(const unsigned char *mac)
{
	return !(mac[0] | mac[1] | mac[2] | mac[3] | mac[4] | mac[5]);
}

long get_seed()
{
	struct timeval t;
	unsigned long seed = 0;
	gettimeofday(&t, NULL);
	seed = 1000000 * t.tv_sec + t.tv_usec;
	WCND_LOGD("generate seed: %lu", seed);
	return seed;
}

/* This function is for internal test only */
void get_random_mac(unsigned char *mac)
{
	int i;

	WCND_LOGD("generate random mac");
	memset(mac, 0, MAC_LEN);

	srand(get_seed()); /* machine run time in us */
	for(i=0; i<MAC_LEN; i++) {
		mac[i] = rand() & 0xFF;
	}

	//mac[0] &= 0xFE; /* clear multicast bit */
	//mac[0] &= 0xFD; /* clear local assignment bit, p2p MAC will be auto generated by set this bit to 1 */
	/* Set Spreadtrum 24bit OUI */
	mac[0] = 0x40;
	mac[1] = 0x45;
	mac[2] = 0xDA;
}

void read_mac_from_file(const char *file_path, unsigned char *mac)
{
	FILE *f;
	unsigned char mac_src[MAC_LEN];
	char buf[20];

	f = fopen(file_path, "r");
	if (f == NULL) return;

	if (fscanf(f, "%02x:%02x:%02x:%02x:%02x:%02x", &mac_src[0], &mac_src[1], &mac_src[2], &mac_src[3], &mac_src[4], &mac_src[5]) == 6) {
		memcpy(mac, mac_src, MAC_LEN);
		sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", mac_src[0], mac_src[1], mac_src[2], mac_src[3], mac_src[4], mac_src[5]);
		WCND_LOGD("mac from configuration file: %s", buf);
	} else {
		memset(mac, 0, MAC_LEN);
	}

	fclose(f);
}

void write_mac_to_file(const char *file_path, const unsigned char *mac)
{
	FILE *f;
	unsigned char mac_src[MAC_LEN];
	char buf[100];

	f = fopen(file_path, "w");
	if (f == NULL) return;

	sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	fputs(buf, f);
	WCND_LOGD("write mac to configuration file: %s", buf);

	fclose(f);

	sprintf(buf, "chmod 666 %s", file_path);
	system(buf);
}

bool is_file_exists(const char *file_path)
{
	return access(file_path, 0) == 0;
}

void force_replace_file(const char *dst_file_path, const char *src_file_path)
{
	FILE *f_src, *f_dst;
	char buf[100];

	f_src = fopen(src_file_path, "r");
	if (f_src == NULL) return;
	fgets(buf, sizeof(buf), f_src);
	fclose(f_src);
	
	f_dst = fopen(dst_file_path, "w");
	if (f_dst == NULL) return;
	fputs(buf, f_dst);
	fclose(f_dst);

	sprintf(buf, "chmod 666 %s", dst_file_path);
	system(buf);
	WCND_LOGD("force_replace_config_file: %s", buf);
}

void generate_wifi_mac()
{
	unsigned char mac[MAC_LEN];
	// force replace configuration file if vaild mac is in factory configuration file
	if(is_file_exists(WCND_WIFI_FACTORY_CONFIG_FILE_PATH)) {
		WCND_LOGD("wifi factory configuration file exists");
		read_mac_from_file(WCND_WIFI_FACTORY_CONFIG_FILE_PATH, mac);
		if(!is_zero_ether_addr(mac)) {
			force_replace_file(WCND_WIFI_CONFIG_FILE_PATH, WCND_WIFI_FACTORY_CONFIG_FILE_PATH);
			return;
		}
	}
	// if vaild mac is in configuration file, use it
	if(is_file_exists(WCND_WIFI_CONFIG_FILE_PATH)) {
		WCND_LOGD("wifi configuration file exists");
		read_mac_from_file(WCND_WIFI_CONFIG_FILE_PATH, mac);
		if(!is_zero_ether_addr(mac)) return;
	}
	// generate random mac and write to configuration file
	get_random_mac(mac);
	write_mac_to_file(WCND_WIFI_CONFIG_FILE_PATH, mac);
}

void generate_bt_mac()
{
	unsigned char mac[MAC_LEN];
	// force replace configuration file if vaild mac is in factory configuration file
	if(is_file_exists(WCND_BT_FACTORY_CONFIG_FILE_PATH)) {
		WCND_LOGD("bt factory configuration file exists");
		read_mac_from_file(WCND_BT_FACTORY_CONFIG_FILE_PATH, mac);
		if(!is_zero_ether_addr(mac)) {
			force_replace_file(WCND_BT_CONFIG_FILE_PATH, WCND_BT_FACTORY_CONFIG_FILE_PATH);
			return;
		}
	}
	// if vaild mac is in configuration file, use it
	if(is_file_exists(WCND_BT_CONFIG_FILE_PATH)) {
		WCND_LOGD("bt configuration file exists");
		read_mac_from_file(WCND_BT_CONFIG_FILE_PATH, mac);
		if(!is_zero_ether_addr(mac)) return;
	}
	// generate random mac and write to configuration file
	get_random_mac(mac);
	mac[0] = 0;
	write_mac_to_file(WCND_BT_CONFIG_FILE_PATH, mac);
}




//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

/**
* pre-define static API.
*/
static int send_back_cmd_result(int client_fd, char *str, int isOK);
static int config_cp2_bootup(WcndManager *pWcndManger);
static void prepare_cp2_recovery(WcndManager *pWcnManager);
/**
* static variables
*/
static WcndManager default_wcn_manager;

/*
* wcn cmd executer to executer cmd that relate to CP2 assert
* such as:
* (1) reset  //to reset the CP2
*/
static const WcnCmdExecuter wcn_cmdexecuter = {
	.name = "wcn",
	.runcommand = wcnd_runcommand,
};

/**
* export API
*/

WcndManager* wcnd_get_default_manager(void)
{
	return &default_wcn_manager;
}

int wcnd_register_cmdexecuter(WcndManager *pWcndManger, const WcnCmdExecuter *pCmdExecuter)
{
	if(!pWcndManger || !pCmdExecuter) return -1;

	if(!pWcndManger->inited)
	{
		WCND_LOGE("WcndManager IS NOT INITIALIZED ! ");
		return -1;
	}

	int i = 0;
	int ret = 0;
	pthread_mutex_lock(&pWcndManger->cmdexecuter_list_lock);

	for (i = 0; i < WCND_MAX_CMD_EXECUTER_NUM; i++)
	{
		if(!pWcndManger->cmdexecuter_list[i]) //empty
		{
			pWcndManger->cmdexecuter_list[i] = pCmdExecuter;
			break;
		}
		else if(pWcndManger->cmdexecuter_list[i] == pCmdExecuter)
		{
			WCND_LOGD("cmd executer:%p has been register before!", pCmdExecuter);
			break;
		}
	}

	pthread_mutex_unlock(&pWcndManger->cmdexecuter_list_lock);

	if( WCND_MAX_CMD_EXECUTER_NUM == i)
	{
		WCND_LOGE("ERRORR::%s: cmdexecuter_list is FULL", __FUNCTION__);
		ret = -1;
	}

	return ret;
}

int wcnd_send_back_cmd_result(int client_fd, char *str, int isOK)
{
	return send_back_cmd_result(client_fd, str, isOK);
}

int wcnd_send_selfcmd(WcndManager *pWcndManger, char *cmd)
{
	return TEMP_FAILURE_RETRY(write(pWcndManger->selfcmd_sockets[0], cmd, strlen(cmd)));
}


/**
* static API
*/
#define OK_STR "OK"
#define FAIL_STR "FAIL"

static int send_back_cmd_result(int client_fd, char *str, int isOK)
{
	char buffer[255];

	if(client_fd < 0) return -1;

	memset(buffer, 0, sizeof(buffer));

	if(!str)
	{
		snprintf(buffer, 255, "%s",  (isOK?OK_STR:FAIL_STR));
	}
	else
	{
		snprintf(buffer, 255, "%s %s", (isOK?OK_STR:FAIL_STR), str);
	}

	int ret = write(client_fd, buffer, strlen(buffer)+1);
	if(ret < 0)
	{
		WCND_LOGE("write %s to client_fd:%d fail (error:%s)", buffer, client_fd, strerror(errno));
		return -1;
	}

	return 0;
}


/**
* cmd format:
* module_name [submodule_name cmd | cmd]  arg1 arg2 ...
* eg:
* wcn reset
* eng iwnapi getmaxpower
* Note: data must end with null character.
*/
static void dispatch_command2(WcndManager *pWcndManger, int client_fd, char *data)
{
	if(!pWcndManger || !data)
	{
		send_back_cmd_result(client_fd, "Null pointer!!", 0);
		return;
	}

	int i, j = 0;
	int argc = 0;

#define WCND_CMD_ARGS_MAX (16)

	char *argv[WCND_CMD_ARGS_MAX];
	char tmp[255];
	char *p = data;
	char *q = tmp;
	char *qlimit = tmp + sizeof(tmp) - 1;
	int esc = 0;
	int quote = 0;
	int k;
	int haveCmdNum = 0;

	memset(argv, 0, sizeof(argv));
	memset(tmp, 0, sizeof(tmp));

	while(*p)
	{
		if (*p == '\\')
		{
			if (esc) {
				if (q >= qlimit)
					goto overflow;
				*q++ = '\\';
				esc = 0;
			} else

			esc = 1;
			p++;
			continue;
		}
		else if (esc)
		{
			if (*p == '"')
			{
				if (q >= qlimit)
					goto overflow;
				*q++ = '"';
			}
			else if (*p == '\\')
			{
				 if (q >= qlimit)
					goto overflow;
				*q++ = '\\';
			 }
			else
			{
				send_back_cmd_result(client_fd, "Unsupported escape sequence", 0);
				goto out;
			}
			p++;
			esc = 0;
			 continue;
		}

		if (*p == '"')
		{
			if (quote)
				quote = 0;
			else
				quote = 1;
			p++;
			continue;
		}

		if (q >= qlimit)
			goto overflow;
		*q = *p++;
		if (!quote && *q == ' ')
		{
			*q = '\0';
			if (haveCmdNum)
			{
				 char *endptr;
				int cmdNum = (int)strtol(tmp, &endptr, 0);
				if (endptr == NULL || *endptr != '\0')
				{
					send_back_cmd_result(client_fd, "Invalid sequence number", 0);
					goto out;
				}
				//TDO Save Cmd Num
				haveCmdNum = 0;
			 }
			else
			{
				if (argc >= WCND_CMD_ARGS_MAX)
					goto overflow;
				argv[argc++] = strdup(tmp);
			}
			memset(tmp, 0, sizeof(tmp));
			q = tmp;
			continue;
		}
		q++;
	}

	*q = '\0';
	if (argc >= WCND_CMD_ARGS_MAX)
		goto overflow;

	argv[argc++] = strdup(tmp);
#if 1
	for (k = 0; k < argc; k++)
	{
		WCND_LOGD("%s: arg[%d] = '%s'", __FUNCTION__ , k, argv[k]);
	}
#endif

	if (quote)
	{
		send_back_cmd_result(client_fd, "Unclosed quotes error", 0);
		goto out;
	}

	cmd_handler handler = NULL;

	pthread_mutex_lock(&pWcndManger->cmdexecuter_list_lock);
	for (i = 0; i <WCND_MAX_CMD_EXECUTER_NUM; ++i)
	{
		if (pWcndManger->cmdexecuter_list[i] && pWcndManger->cmdexecuter_list[i]->name &&
			(!strcmp(argv[0], pWcndManger->cmdexecuter_list[i]->name)))
		{
			handler = pWcndManger->cmdexecuter_list[i]->runcommand;
			break;
		}
	}
	pthread_mutex_unlock(&pWcndManger->cmdexecuter_list_lock);

	if(!handler)
	{
		send_back_cmd_result(client_fd, "Command not recognized", 0);
		goto out;

	}

	handler(client_fd, argc-1, &argv[1]);

out:
	for (j = 0; j < argc; j++)
		free(argv[j]);
	return;

overflow:
	send_back_cmd_result(client_fd, "Command too long", 0);
	goto out;
}

/**
* if it is a engineer mode command, dispatch it to engineer worker thread
*/
static int worker_dispatch(WcndManager *pWcndManger, int client_fd, char *data)
{
	if(!pWcndManger || !data)
	{
		send_back_cmd_result(client_fd, "Null pointer!!", 0);
		return -1;
	}

	//for engineer mode command, dispatch it to engineer worker thread
	if(strstr(data, "eng"))
	{
		if(wcnd_worker_dispatch(pWcndManger, wcnd_woker_handle, data, client_fd, 0) < 0)
		{
			send_back_cmd_result(client_fd, "eng cmd dispatch error!!", 0);
			return -1;
		}

		return 0;
	}

	dispatch_command2(pWcndManger, client_fd, data) ;

	return 0;
}

/**
* the data string may contain multi cmds, each cmds end with null character.
*/
static void dispatch_command(WcndManager *pWcndManger, int client_fd, char *data, int data_len)
{
	char buffer[255];
	int count = 0, start = 0, end = data_len;

	if(!data || data_len >= 255) return;
	memset(buffer, 0, sizeof(buffer));
	memcpy(buffer, data, data_len);
	while(buffer[count] == ' ')count++; //remove blankspace

	start = count ;

	while(count < end)
	{
		if(buffer[count] == '\0')
		{
			if(start < count)
			{
				worker_dispatch(pWcndManger, client_fd, buffer+start) ;
			}
			start = count + 1;
		}

		count++;
	}

	if(buffer[end] != '\0')
	{
		WCND_LOGE("%s: cmd should end with null character!", __FUNCTION__);
	}
	else if(start < count)
	{
		worker_dispatch(pWcndManger, client_fd, buffer+start) ;
	}

	return;
}


/**
* To handle the worker. That is to handle the command.
*/
int wcnd_woker_handle(void *worker)
{
	if(!worker) return -1;
	WcndWorker *pWorker = (WcndWorker*)worker;
	WcndManager *pWcndManger = (WcndManager *)(pWorker->ctx);
	int client_fd = pWorker->replyto_fd;
	char *data = pWorker->data;

	if(!pWcndManger || !data)
	{
		send_back_cmd_result(client_fd, "Null pointer!!", 0);
		return -1;
	}

	dispatch_command2(pWcndManger, client_fd, data) ;

	return 0;
}

////////////////command handler related code end/////////////////////


/**
* may do some clear action that will used during reset
* such as wcnlog.result property.
*/
static void pre_send_cp2_exception_notify(void)
{
	/* Erase any previous setting of the slogresult property */
	property_set(WCND_SLOG_RESULT_PROP_KEY, "0");
}


/**
* check "ro.modem.wcn.enable" property to see if cp2 enabled or not.
* default is enabled
* return non-zero for true.
*/
static int check_if_wcnmodem_enable(void)
{
	char value[PROPERTY_VALUE_MAX] = {'\0'};

	property_get(WCND_MODEM_ENABLE_PROP_KEY, value, "1");
	int is_enabled = atoi(value);

	return is_enabled;
}

/*
 * To block the pipe signal to avoid the process exit.
 */
static void blockSigpipe(void)
{
	sigset_t mask;

	sigemptyset(&mask);
	sigaddset(&mask, SIGPIPE);

	if (sigprocmask(SIG_BLOCK, &mask, NULL) != 0)
		WCND_LOGD("WARNING: SIGPIPE not blocked\n");
}

/**
* store the fd in the client_fds array.
* when the array is full, then something will go wrong, so please NOTE!!!
*/
static void store_client_fd(int client_fds[], int fd)
{
	if(!client_fds) return;

	int i = 0;

	for (i = 0; i < WCND_MAX_CLIENT_NUM; i++)
	{
		if(client_fds[i] == -1) //invalid fd
		{
			client_fds[i] = fd;
			return;
		}
		else if(client_fds[i] == fd)
		{
			WCND_LOGD("%s: Somethine error happens. restore the same fd:%d", __FUNCTION__, fd);
			return;
		}
	}

	//if full, ignore the last one, and save the new one
	if(i == WCND_MAX_CLIENT_NUM)
	{
		WCND_LOGD("ERRORR::%s: client_fds is FULL", __FUNCTION__);
		client_fds[i-1] = fd;
		return;
	}
}

#define RDWR_FD_FAIL (-2)
#define GENERIC_FAIL (-1)

/**
* process the active client fd ( the client close the remote socket or send something)
*
* return < 0 for fail;
* TODO: can handle the cmd sent from the client here
*/
static int process_active_client_fd(WcndManager *pWcndManger, int fd)
{
	char buffer[255];
	int len;

	memset(buffer, 0, sizeof(buffer));
	len = TEMP_FAILURE_RETRY(read(fd, buffer, sizeof(buffer)-1));//reserve last byte for null character.
	if (len < 0)
	{
		WCND_LOGD("read() failed (%s)", strerror(errno));
		return RDWR_FD_FAIL;
	}
	else if (!len)
	{
		WCND_LOGD("read() failed, the peer of fd(%d) is shutdown", fd);
		return RDWR_FD_FAIL;
	}

	dispatch_command(pWcndManger, fd, buffer, len+1);//len+1 make sure string end with null character.

	return 0;
}

/**
* listen on the server socket for accept connection from client.
* and then also set the client socket to select read fds for:
* 1. to detect the exception from client, then to close the client socket.
* 2. to process the cmd from client in feature.
*/
static void *client_listen_thread(void *arg)
{
	WcndManager *pWcndManger = (WcndManager *)arg;

	if(!pWcndManger)
	{
		WCND_LOGD("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		exit(-1);
	}

	int pending_fds[WCND_MAX_CLIENT_NUM];
	memset(pending_fds, -1, sizeof(pending_fds));

	while(1)
	{
		int  i = 0;
		fd_set read_fds;
		int rc = 0;
		int max = -1;

		FD_ZERO(&read_fds);

		max = pWcndManger->listen_fd;
		FD_SET(pWcndManger->listen_fd, &read_fds);

		FD_SET(pWcndManger->selfcmd_sockets[1], &read_fds);
		if (pWcndManger->selfcmd_sockets[1] > max)
			max = pWcndManger->selfcmd_sockets[1];

		//if need to deal with the cmd sent from client, here add them to read_fds
		pthread_mutex_lock(&pWcndManger->clients_lock);
		for (i = 0; i < WCND_MAX_CLIENT_NUM; i++)
		{
			int fd = pWcndManger->clients[i].sockfd;
			if(fd != -1) //valid fd
			{
				FD_SET(fd, &read_fds);
				if (fd > max)
					max = fd;
			}
		}
		pthread_mutex_unlock(&pWcndManger->clients_lock);

		WCND_LOGD("listen_fd = %d, max=%d", pWcndManger->listen_fd, max);
		if ((rc = select(max + 1, &read_fds, NULL, NULL, NULL)) < 0)
		{
			if (errno == EINTR)
				continue;

			WCND_LOGD("select failed (%s) listen_fd = %d, max=%d", strerror(errno), pWcndManger->listen_fd, max);
			sleep(1);
			continue;
		}
		else if (!rc)
			continue;

		if (FD_ISSET(pWcndManger->listen_fd, &read_fds))
		{
			struct sockaddr addr;
			socklen_t alen;
			int c;

			//accept the client connection
			do {
				alen = sizeof(addr);
				c = accept(pWcndManger->listen_fd, &addr, &alen);
				WCND_LOGD("%s got %d from accept", WCND_SOCKET_NAME, c);
			} while (c < 0 && errno == EINTR);

			if (c < 0)
			{
				WCND_LOGE("accept failed (%s)", strerror(errno));
				sleep(1);
				continue;
			}

			//save client
			pthread_mutex_lock(&pWcndManger->clients_lock);
			for (i = 0; i < WCND_MAX_CLIENT_NUM; i++)
			{
				if(pWcndManger->clients[i].sockfd == -1) //invalid fd
				{
					pWcndManger->clients[i].sockfd = c;
					pWcndManger->clients[i].type = WCND_CLIENT_TYPE_NOTIFY;
					break;

				}
				else if(pWcndManger->clients[i].sockfd == c)
				{
					WCND_LOGD("%s: Somethine error happens. restore the same fd:%d", __FUNCTION__, c);
					break;
				}
			}

			//if full, ignore the last one, and save the new one
			if(i == WCND_MAX_CLIENT_NUM)
			{
				WCND_LOGD("ERRORR::%s: clients is FULL", __FUNCTION__);
				close(c);
			}
			pthread_mutex_unlock(&pWcndManger->clients_lock);
		}

		/* TODO:   */

		/* Add all active clients to the pending list first */
		memset(pending_fds, -1, sizeof(pending_fds));
		pthread_mutex_lock(&pWcndManger->clients_lock);
		for (i = 0; i<WCND_MAX_CLIENT_NUM; i++)
		{
			int fd = pWcndManger->clients[i].sockfd;
			if ((fd!= -1) && FD_ISSET(fd, &read_fds))
			{
				store_client_fd(pending_fds, fd);
			}
		}
		pthread_mutex_unlock(&pWcndManger->clients_lock);


		if (FD_ISSET(pWcndManger->selfcmd_sockets[1], &read_fds))
			store_client_fd(pending_fds, pWcndManger->selfcmd_sockets[1]);


		/* Process the pending list, since it is owned by the thread, there is no need to lock it */
		for (i = 0; i<WCND_MAX_CLIENT_NUM; i++)
		{
			int fd = pending_fds[i];

			/* remove from the pending list */
			pending_fds[i] = -1;

			/* Process it, if fail is returned and our sockets are connection-based, remove and destroy it */
			if( (fd != -1) && (process_active_client_fd(pWcndManger, fd)  == RDWR_FD_FAIL))
			{
				int j = 0;

				/* Remove the client from our array */
				WCND_LOGD("going to zap %d for %s", fd, WCND_SOCKET_NAME);
				pthread_mutex_lock(&pWcndManger->clients_lock);
				for (j = 0; j<WCND_MAX_CLIENT_NUM; j++)
				{
					if (pWcndManger->clients[j].sockfd == fd) {
						close(fd); //close the socket
						pWcndManger->clients[j].sockfd = -1;
						pWcndManger->clients[j].type = WCND_CLIENT_TYPE_NOTIFY;
						break;
					}
				}
				pthread_mutex_unlock(&pWcndManger->clients_lock);
			}
		}

	}

}


/**
* Note: message send from wcnd must end with null character
*             use null character to identify a completed message.
*/
static int send_msg(WcndManager *pWcndManger, int client_fd, char *msg_str)
{
	if(!pWcndManger || !msg_str) return GENERIC_FAIL;

	char *buf;

	pWcndManger->notify_count++;
	buf = msg_str;

	/* Send the zero-terminated message */

	//Note: message send from wcnd must end with null character
	//use null character to identify a completed message.
	int len = strlen(buf) + 1; //including null character

	WCND_LOGD("send %s to client_fd:%d", buf, client_fd);

	int ret = TEMP_FAILURE_RETRY(write(client_fd, buf, len));
	if(ret < 0)
	{
		WCND_LOGE("write %d bytes to client_fd:%d fail (error:%s)", len, client_fd, strerror(errno));
		ret = RDWR_FD_FAIL;
	}

	return ret;
}

/**
* send notify information to all the connected clients.
* return -1 for fail
* Note: message send from wcnd must end with null character
*             use null character to identify a completed message.
*/
int wcnd_send_notify_to_client(WcndManager *pWcndManger, char *info_str, int notify_type)
{
	int i, ret;

	if(!pWcndManger || !info_str) return -1;

	WCND_LOGD("send_notify_to_client (type:%d)", notify_type);

	if(notify_type == WCND_CLIENT_TYPE_NOTIFY && !pWcndManger->notify_enabled)
	{
		WCND_LOGD("do not need to send_notify_to_client, just return!!");
		return 0;
	}

	pthread_mutex_lock(&pWcndManger->clients_lock);

	/* info socket clients that WCN with str info */
	for(i = 0; i < WCND_MAX_CLIENT_NUM; i++)
	{
		int fd = pWcndManger->clients[i].sockfd;
		int type = pWcndManger->clients[i].type;
		WCND_LOGD("clients[%d].sockfd = %d, type = %d\n",i, fd, type);

		if(fd >= 0 && ((type == notify_type)
			|| ((notify_type == WCND_CLIENT_TYPE_CMD) && ((type & WCND_CLIENT_TYPE_CMD_MASK) == notify_type)))
			)
		{
			ret = send_msg(pWcndManger, fd, info_str);
			if(RDWR_FD_FAIL == ret)
			{
				WCND_LOGD("reset clients[%d].sockfd = -1",i);
				close(fd);
				pWcndManger->clients[i].sockfd = -1;
				pWcndManger->clients[i].type = WCND_CLIENT_TYPE_NOTIFY;
			}
			else if(notify_type == WCND_CLIENT_TYPE_CMD || notify_type == WCND_CLIENT_TYPE_CMD_PENDING
				|| (notify_type & WCND_CLIENT_TYPE_CMD_MASK) == WCND_CLIENT_TYPE_CMD)
			{
				pWcndManger->clients[i].type = WCND_CLIENT_TYPE_SLEEP;
			}

		}
	}

	pthread_mutex_unlock(&pWcndManger->clients_lock);

	return 0;
}

/*
* polling /dev/spipe_wcn0, do write and read testing.
* is_loopcheck: if true use select.
*     if false use NONBLOCK mode, because after downloading image and starting CP2, the cp2 may not receive the string
*     that wrote to the /dev/spipe_wcn0, for it is not inited completely.
* Note: return 0 for OK; return -1 for fail
*/
static int is_cp2_alive_ok(WcndManager *pWcndManger, int is_loopcheck)
{
	int len = 0;
	int loop_fd = -1;

	//block mode for using select
	if(is_loopcheck)
	    loop_fd = open( pWcndManger->wcn_loop_iface_name, O_RDWR/*|O_NONBLOCK*/);
	else
            loop_fd = open( pWcndManger->wcn_loop_iface_name, O_RDWR|O_NONBLOCK);

	WCND_LOGD("%s: open polling interface: %s, fd = %d", __func__, pWcndManger->wcn_loop_iface_name, loop_fd);
	if (loop_fd < 0)
	{
		WCND_LOGE("open %s failed, error: %s", pWcndManger->wcn_loop_iface_name, strerror(errno));
		return -1;
	}

	len = write(loop_fd, LOOP_TEST_STR, strlen(LOOP_TEST_STR));
	if(len < 0)
	{
		WCND_LOGE("%s: write %s failed, error:%s", __func__, pWcndManger->wcn_loop_iface_name, strerror(errno));
		close(loop_fd);
		return -1;
	}

       //if it is not loop check, use select instead
	if(!is_loopcheck)
	{
		//WCND_LOGD("nonblock loop check");

		//wait
		usleep(100*1000);

		char buffer[32];
		memset(buffer, 0, sizeof(buffer));
		do {
			len = read(loop_fd, buffer, sizeof(buffer));
		} while(len < 0 && errno == EINTR);

		if ((len <= 0) || !strstr(buffer,LOOP_TEST_ACK_STR))
		{
			WCND_LOGE("%s: read %d return %d, buffer:%s,  errno = %s", __func__, loop_fd , len, buffer, strerror(errno));
			close(loop_fd);
			return -1;
		}
	}
	else
	{
		fd_set read_fds;
		int rc = 0;
		int max = -1;
		struct timeval timeout;

		//WCND_LOGD("select loop check");

		FD_ZERO(&read_fds);

		max = loop_fd;
		FD_SET(loop_fd, &read_fds);

		//time out 2.5 seconds
		timeout.tv_sec = 2;
		timeout.tv_usec = 500000;

	select_retry:
		if ((rc = select(max + 1, &read_fds, NULL, NULL, &timeout)) < 0)
		{
			if (errno == EINTR)
				goto select_retry;

			WCND_LOGD("select loop_fd(%d) failed: %s", loop_fd, strerror(errno));
			close(loop_fd);
			return -1;
		}
		else if (!rc)
		{
			WCND_LOGD("select loop_fd(%d) TimeOut", loop_fd);
			close(loop_fd);
			return -1;
		}

		if (!(FD_ISSET(loop_fd, &read_fds)))
		{
			WCND_LOGD("select loop_fd(%d) return > 0, but loop_fd is not set!", loop_fd);
			close(loop_fd);
			return -1;
		}

		char buffer[32];
		memset(buffer, 0, sizeof(buffer));
		do {
			len = read(loop_fd, buffer, sizeof(buffer));
		} while(len < 0 && errno == EINTR);

		if ((len <= 0) || !strstr(buffer,LOOP_TEST_ACK_STR))
		{
			WCND_LOGE("%s: read %d return %d, buffer:%s,  errno = %s", __func__, loop_fd , len, buffer, strerror(errno));
			close(loop_fd);
			return -1;
		}
	}

	WCND_LOGD("%s: loop: %s is OK", __func__, pWcndManger->wcn_loop_iface_name);

	close(loop_fd);

	return 0;
}


#define WATI_FOR_CP2_READY_TIME_MSECS (100)
#define MAX_LOOP_TEST_COUNT (50)
#define LOOP_TEST_INTERVAL_MSECS (100)
#define RESET_FAIL_RETRY_COUNT (3)
#define RESET_RETRY_INTERVAL_MSECS (2000)

/**
* Return 0: for polling test OK.
* -1: for fail
*/
static int polling_test_after_reset(WcndManager *pWcndManger)
{
	int loop_test_count = 0;

polling_test:
	//polling loop interface to check if CP2 is boot up complete.
	if(loop_test_count++ > MAX_LOOP_TEST_COUNT)
	{
		WCND_LOGE("%s: write test for %d counts, still failed return!!!!!", __func__, MAX_LOOP_TEST_COUNT);
		return -1;
	}

	if(is_cp2_alive_ok(pWcndManger, 0)<0)
	{
		//wait a moment, and go on.
		//usleep(LOOP_TEST_INTERVAL_MSECS*1000);
		goto polling_test;

	}

	return 0;

}


/**
* do cp2 reset processtrue:
* 1. notify connected clients "cp2 reset start"
* 2. reset cp2
* 3. notify connected clients "cp2 reset end"
*/
int wcnd_do_wcn_reset_process(WcndManager *pWcndManger)
{
	WcndMessage message;

	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return -1;
	}

	prepare_cp2_recovery(pWcndManger);

	int is_alive_ok = 1;

	if(wcnd_before_reset(pWcndManger) < 0)
	{
		WCND_LOGD("%s: wcn reset disabled, do not do reset!", __FUNCTION__);
		return 0;
	}

	int reset_count = 0;

do_cp2reset:

	if(reset_count++ > RESET_FAIL_RETRY_COUNT)
	{
		WCND_LOGE("%s Reset CP2 for %d times, still failed return!!!!!", __func__, RESET_FAIL_RETRY_COUNT);
		//clear doing_reset flag
		pWcndManger->doing_reset = 0;
		//return  0;
		is_alive_ok = 0;
		goto out;
	}

	//Notify client reset start
	wcnd_send_notify_to_client(pWcndManger, WCND_CP2_RESET_START_STRING, WCND_CLIENT_TYPE_NOTIFY);

#ifdef CP2_RESET_READY
	//begin reseting CP2
	int ret = wcnd_reboot_cp2(pWcndManger);

	//Notify client reset completed.
	wcnd_send_notify_to_client(pWcndManger, WCND_CP2_RESET_END_STRING, WCND_CLIENT_TYPE_NOTIFY);

	if(ret < 0)
	{
		WCND_LOGD("%s: reboot CP2 Fail !", __FUNCTION__);
		is_alive_ok = 0;
	}
	else
	{
		//wait for a moment
		//usleep(WATI_FOR_CP2_READY_TIME_MSECS*1000);

		if(polling_test_after_reset(pWcndManger) < 0)
		{
			is_alive_ok = 0;
		}

	}
#endif

	//Notify CP2 alive again
	if(is_alive_ok)
		wcnd_send_notify_to_client(pWcndManger, WCND_CP2_ALIVE_STRING, WCND_CLIENT_TYPE_NOTIFY);
	else
	{
		usleep(RESET_RETRY_INTERVAL_MSECS*1000);
		is_alive_ok = 1;
		goto do_cp2reset;
	}

	//clear doing_reset flag
	pWcndManger->doing_reset = 0;

out:
	//clear the cp2 error flag.
	if(is_alive_ok)
	{
		message.event = WCND_EVENT_CP2_OK;
		message.replyto_fd = -1;
		pWcndManger->is_cp2_error = 0;

		//set CP2 status to be ok
		property_set(WCND_CP2_STATE_PROP_KEY, "ok");
	}
	else
	{
		message.event = WCND_EVENT_CP2_DOWN;
		message.replyto_fd = -1;
	}

	wcnd_sm_step(pWcndManger, &message);

	if(is_alive_ok)
	{
		WCND_LOGD("%s: config CP2 bootup after reset OK!!", __FUNCTION__);
		config_cp2_bootup(pWcndManger);
	}

	return 0;
}


/**
* open cp2 processure:
* 1. reset cp2
*/
int wcnd_open_cp2(WcndManager *pWcndManger)
{
	WcndMessage message;

	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return -1;
	}

#ifdef WCND_CP2_POWER_ONOFF_ENABLE

	int is_alive_ok = 1;

	//set doing_reset flag
	pWcndManger->doing_reset = 1;

	int reset_count = 0;

do_cp2reset:

	if(reset_count++ > RESET_FAIL_RETRY_COUNT)
	{
		WCND_LOGE("%s Reset CP2 for %d times, still failed return!!!!!", __func__, RESET_FAIL_RETRY_COUNT);
		//clear doing_reset flag
		pWcndManger->doing_reset = 0;
		is_alive_ok = 0;
		goto out;
	}


#ifdef CP2_RESET_READY
	//begin open CP2
	int ret = wcnd_start_cp2(pWcndManger);
	if( ret < 0)
	{
		WCND_LOGD("%s: open Fail !", __FUNCTION__);
		is_alive_ok = 0;
	}
	else
	{
		//wait for a moment
		//usleep(WATI_FOR_CP2_READY_TIME_MSECS*1000);
		if(polling_test_after_reset(pWcndManger) < 0)
		{
			is_alive_ok = 0;
		}
	}
#endif


	//Notify CP2 alive again
	if(!is_alive_ok)
	{
		usleep(RESET_RETRY_INTERVAL_MSECS*1000);
		is_alive_ok = 1;
		goto do_cp2reset;
	}

	//clear doing_reset flag
	pWcndManger->doing_reset = 0;

out:
	//clear the cp2 error flag.
	if(is_alive_ok)
	{
		message.event = WCND_EVENT_CP2_OK;
		message.replyto_fd = -1;
		pWcndManger->is_cp2_error = 0;
	}
	else
	{
		message.event = WCND_EVENT_CP2_DOWN;
		message.replyto_fd = -1;
	}

#else

	int is_alive_ok = 0;

	message.event = WCND_EVENT_CP2_OK;
	message.replyto_fd = -1;
	pWcndManger->is_cp2_error = 0;

#endif //WCND_CP2_POWER_ONOFF_ENABLE

	wcnd_sm_step(pWcndManger, &message);


	if(is_alive_ok)
	{
		WCND_LOGD("%s: config CP2 bootup after open CP2 !!", __FUNCTION__);
		config_cp2_bootup(pWcndManger);
	}


	return 0;
}

/**
* close cp2 processure:
*/
int wcnd_close_cp2(WcndManager *pWcndManger)
{
	WcndMessage message;

	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return -1;
	}

#ifdef WCND_CP2_POWER_ONOFF_ENABLE

#ifdef USE_MARLIN

	//marlin do not need to send sleep cmd

	if(wcnd_stop_cp2(pWcndManger) < 0)
	{
		WCND_LOGE("%s: Stop CP2 failed!!", __FUNCTION__);
		//return -1;
	}

#else

	//Tell CP2 to Sleep
	if(wcnd_process_atcmd(-1, WCND_ATCMD_CP2_SLEEP, pWcndManger) < 0)
	{
		WCND_LOGE("%s: CP2 SLEEP failed!! Before stop it!!", __FUNCTION__);
		goto out;
	}

	if(wcnd_stop_cp2(pWcndManger) < 0)
	{
		WCND_LOGE("%s: Stop CP2 failed!!", __FUNCTION__);
		//return -1;
	}

out:

#endif //USE_MARLIN

#endif

	message.event = WCND_EVENT_CP2_DOWN;
	message.replyto_fd = -1;
	wcnd_sm_step(pWcndManger, &message);

	return 0;
}


int wcnd_dump_cp2(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

	//set to prevent loop check
	pWcndManger->is_cp2_error = 1;

	//to kill the BT/WIFI
	prepare_cp2_recovery(pWcndManger);

	//dump mem
	wcnd_dump_cp2_mem(pWcndManger);

	//clear
	pWcndManger->is_cp2_error = 0;

	return 0;
}




/**
* do some config for cp2 when cp2 power on
*/
int wcnd_config_cp2_bootup(WcndManager *pWcndManger)
{
	return config_cp2_bootup(pWcndManger);
}


/**
* do some prepare work, before dump/reset cp2
*/
static void prepare_cp2_recovery(WcndManager *pWcndManger)
{
	//kill supplicant
	//property_set("ctl.stop", "wpa_supplicant");
	//property_set("ctl.stop", "p2p_supplicant");
	wcnd_kill_process_by_name("/system/bin/wpa_supplicant", SIGINT);

	wcnd_wait_for_supplicant_stopped();

	/* down the wifi network interface */
	wcnd_down_network_interface("wlan0");

	//move after waiting wifi driver unloaded, because wifi driver unloaded may cause too much time
	//and make bt preload timeout, so need to restart bt
#if 0
	//kill bluetooth
	wcnd_kill_process_by_name("com.android.bluetooth", SIGKILL);


	//check if bt process is killed
	int count = 2;
	while(count > 0)
	{
		if (!wcnd_find_process_by_name("com.android.bluetooth"))
			break;
		else
			count--;
		usleep(100*1000); //100ms
	}
#endif

	//kill fm??

#ifdef WCND_CHECK_DRIVER_BEFORE_RESET
	WCND_LOGD("check WIFI driver to be unloaded\n");

	//if(pWcndManger && pWcndManger->wait_wifi_driver_unloaded) //wait for wifi driver to be unloaded, otherwise reset may fail
		wcnd_wait_for_driver_unloaded();

	pWcndManger->wait_wifi_driver_unloaded = 0;
#endif

	//kill bluetooth
	int ret = wcnd_kill_process_by_name("com.android.bluetooth", SIGINT);

	if(-2 != ret) // have send sig to target process, wait it to exit
	{
		//check if bt process is killed
		//Bug#450036 bt cost more than 2s to exit when receive SIGINT -->
		int count = 50;
		while(count > 0)
		{
			if (!wcnd_check_process_exist("com.android.bluetooth", ret))
				break;
			else
				count--;
			usleep(100*1000); //100ms
		}
	}

	//to do reset
	//wcnd_send_selfcmd(pWcndManger, "wcn reset"); //move to handle WCND_EVENT_CP2_ASSERT in state machine

}


static int notify_cp2_exception(WcndManager *pWcndManger, char *info_str)
{
	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return -1;
	}

	//set CP2 status to be assert
	property_set(WCND_CP2_STATE_PROP_KEY, "assert");

	//notify wifi driver, cp2 is assert
	if(1 == wcnd_notify_wifi_driver_cp2_state(0))
	{
		WCND_LOGD("need to wait wifi driver to be unloaded before resetting");
		pWcndManger->wait_wifi_driver_unloaded = 1;
	}


	char buffer[255];

	pre_send_cp2_exception_notify();

	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_SELF_EVENT_CP2_ASSERT);

	//notify exception
	if(info_str)
		snprintf(buffer, 255, "%s %s", WCND_CP2_EXCEPTION_STRING, info_str);
	else
		snprintf(buffer, 255, "%s", WCND_CP2_EXCEPTION_STRING);

	wcnd_send_notify_to_client(pWcndManger, buffer, WCND_CLIENT_TYPE_NOTIFY);

	return 0;
}


/**
* handle the cp2 assert
* 1. send notify to client the cp2 assert
* 2. reset cp2
* 3. send notify to client the cp2 reset completed
*/
static int handle_cp2_assert(WcndManager *pWcndManger, int assert_fd )
{
	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return -1;
	}

	WCND_LOGD("handle_cp2_assert\n");

	//set the cp2 error flag, it is cleared when reset successfully
	pWcndManger->is_cp2_error = 1;

	char rdbuffer[200];
	//char buffer[255];
	int len;

	//memset(buffer, 0, sizeof(buffer));
	memset(rdbuffer, 0, sizeof(rdbuffer));

	len = read(assert_fd, rdbuffer, sizeof(rdbuffer));
	if (len <= 0)
	{
		WCND_LOGE("read %d return %d, errno = %s", assert_fd , len, strerror(errno));
		//return -1;
	}

	//reseting is going on just return
	if(pWcndManger->doing_reset)
		return 0;

#if 0
	pre_send_cp2_exception_notify();

	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_SELF_EVENT_CP2_ASSERT);

	//notify exception
	snprintf(buffer, 255, "%s %s", WCND_CP2_EXCEPTION_STRING, rdbuffer);
	wcnd_send_notify_to_client(pWcndManger, buffer, WCND_CLIENT_TYPE_NOTIFY);


	prepare_cp2_recovery(pWcndManger);

	//currently the reset is done when receive reset cmd from WcnManagerService.java
#endif

	notify_cp2_exception(pWcndManger, rdbuffer);

	WCND_LOGD("handle_cp2_assert end!\n");

	return 0;
}


/**
* handle cp2 watchdog execption
* 1. send notify to client the cp2 cp2 watchdog execption
* 2. reset cp2
* 3. send notify to client the cp2 reset completed
*/
static int handle_cp2_watchdog_exception(WcndManager *pWcndManger, int watchdog_fd )
{
	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return -1;
	}

	WCND_LOGD("handle_cp2_watchdog_exception\n");

	//set the cp2 error flag, it is cleared when reset successfully
	pWcndManger->is_cp2_error = 1;

	char rdbuffer[200];
	//char buffer[255];
	int len;

	//memset(buffer, 0, sizeof(buffer));
	memset(rdbuffer, 0, sizeof(rdbuffer));

	len = read(watchdog_fd, rdbuffer, sizeof(rdbuffer));
	if (len <= 0)
	{
		WCND_LOGE("read %d return %d, errno = %s", watchdog_fd , len, strerror(errno));
		//return -1;
	}

	//reseting is going on just return
	if(pWcndManger->doing_reset)
		return 0;

#if 0
	pre_send_cp2_exception_notify();

	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_SELF_EVENT_CP2_ASSERT);

	//notify exception
	snprintf(buffer, 255, "%s %s", WCND_CP2_EXCEPTION_STRING, rdbuffer);
	wcnd_send_notify_to_client(pWcndManger, buffer, WCND_CLIENT_TYPE_NOTIFY);


	prepare_cp2_recovery(pWcndManger);

	//currently the reset is done when receive reset cmd from WcnManagerService.java
#endif

	notify_cp2_exception(pWcndManger, rdbuffer);

	WCND_LOGD("handle_cp2_watchdog_exception end\n");

	return 0;
}


static void *cp2_listen_thread(void *arg)
{
	WcndManager *pWcndManger = (WcndManager *)arg;

	if(!pWcndManger)
	{
		WCND_LOGD("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		exit(-1);
	}

	int assert_fd = -1;
	int watchdog_fd = -1;

get_assertfd:
	assert_fd = open( pWcndManger->wcn_assert_iface_name, O_RDWR);
	WCND_LOGD("%s: open assert dev: %s, fd = %d", __func__, pWcndManger->wcn_assert_iface_name, assert_fd);
	if (assert_fd < 0)
	{
		WCND_LOGD("open %s failed, error: %s", pWcndManger->wcn_assert_iface_name, strerror(errno));
		sleep(2);
		goto get_assertfd;
		//return NULL;
	}

get_watchdogfd:
	watchdog_fd = open( pWcndManger->wcn_watchdog_iface_name, O_RDWR);
	WCND_LOGD("%s: open watchdog dev: %s, fd = %d", __func__, pWcndManger->wcn_watchdog_iface_name, watchdog_fd);
	if (watchdog_fd < 0)
	{
		WCND_LOGD("open %s failed, error: %s", pWcndManger->wcn_watchdog_iface_name, strerror(errno));
		//close(assert_fd);
		//return NULL;
		sleep(2);
		goto get_watchdogfd;
	}

	while(1)
	{
		int  i = 0;
		fd_set read_fds;
		int rc = 0;
		int max = -1;

		FD_ZERO(&read_fds);

		max = assert_fd;
		FD_SET(assert_fd, &read_fds);

		FD_SET(watchdog_fd, &read_fds);
		if (watchdog_fd > max)
			max = watchdog_fd;

		WCND_LOGD("assert_fd = %d, watchdog_fd = %d, max=%d", assert_fd, watchdog_fd, max);
		if ((rc = select(max + 1, &read_fds, NULL, NULL, NULL)) < 0)
		{
			if (errno == EINTR)
				continue;

			WCND_LOGD("select failed assert_fd = %d, watchdog_fd = %d, max=%d", assert_fd, watchdog_fd, max);
			sleep(1);
			continue;
		}
		else if (!rc)
			continue;

		if (FD_ISSET(assert_fd, &read_fds))
		{
			//there is exception from assert.
			handle_cp2_assert(pWcndManger, assert_fd);
		}

		if (FD_ISSET(watchdog_fd, &read_fds))
		{
			//there is exception from watchdog.
			handle_cp2_watchdog_exception(pWcndManger, watchdog_fd);
		}

		//sleep for a while before going to next polling
		sleep(1);

		/* TODO:   */

	}
}

/**
* Start thread to listen for connection from clients.
* return -1 fail;
*/
static int start_client_listener(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

	pthread_t thread_id;

	if (pthread_create(&thread_id, NULL, client_listen_thread, pWcndManger))
	{
		WCND_LOGE("start_client_listener: pthread_create (%s)", strerror(errno));
		return -1;
	}

	return 0;

}

/**
* Start thread to listen on the CP2 assert/watchdog interface to detect CP2 exception
* return -1 fail;
*/
static int start_cp2_listener(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

	if(pWcndManger->is_eng_mode_only) return 0;

	if(!pWcndManger->is_wcn_modem_enabled) return 0;

	pthread_t thread_id;

	if (pthread_create(&thread_id, NULL, cp2_listen_thread, pWcndManger))
	{
		WCND_LOGE("start_cp2_listener: pthread_create (%s)", strerror(errno));
		return -1;
	}

	return 0;
}


/**
 * Check the kernel command line
 * if in eng autotest mode, when wcnd will start engpcclientwcn
 * return 0: not in the engtest autotest mode
 * return 1: in the engtest autotest mode
 */
static int check_kernel_cmdline(WcndManager *pWcndManger)
{
	int fd = 0;
	char cmdline[1024] = {0};
	int eng_autotest = 0;

	WCND_LOGD("check_kernel_cmdline");

	fd = open("/proc/cmdline", O_RDONLY);
	if(fd >= 0)
	{
		if(read(fd, cmdline, sizeof(cmdline)-1) > 0)
		{
			WCND_LOGD("kernel cmd line: %s", cmdline);

			if(strstr(cmdline, WCND_ENG_AUTOTEST_STRING))
			{
				WCND_LOGD("in eng autotest mode!!!");
				eng_autotest = 1;
				if (pWcndManger)
					pWcndManger->eng_autotest = 1;
			}
		}
		close(fd);
	}
	else
	{
		WCND_LOGE("open /proc/cmdline failed, error: %s", strerror(errno));
	}

	return eng_autotest;
}




/**
* Initial the wcnd manager struct.
* return -1 for fail;
*/
static int init(WcndManager *pWcndManger, int is_eng_only)
{
	if(!pWcndManger) return -1;

	memset(pWcndManger, 0, sizeof(WcndManager));

	int i = 0;

	pthread_mutex_init(&pWcndManger->clients_lock, NULL);
	pthread_mutex_init(&pWcndManger->cmdexecuter_list_lock, NULL);

	for(i=0; i<WCND_MAX_CLIENT_NUM; i++)
		pWcndManger->clients[i].sockfd = -1;

	pWcndManger->is_eng_mode_only = is_eng_only;
	if(pWcndManger->is_eng_mode_only)
	{
		WCND_LOGE("%s: ONLY for engineer mode!!", __FUNCTION__);

		pWcndManger->listen_fd = socket_local_server(WCND_ENG_SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM);
		if (pWcndManger->listen_fd < 0) {
			WCND_LOGE("%s: cannot create local socket server", __FUNCTION__);
			return -1;
		}
	}
	else
	{
		pWcndManger->listen_fd = socket_local_server(WCND_SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM);
		if (pWcndManger->listen_fd < 0) {
			WCND_LOGE("%s: cannot create local socket server", __FUNCTION__);
			return -1;
		}
	}

	snprintf(pWcndManger->wcn_assert_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_ASSERT_IFACE);
	snprintf(pWcndManger->wcn_watchdog_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_WATCHDOG_IFACE);
	snprintf(pWcndManger->wcn_loop_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_LOOP_IFACE);
	snprintf(pWcndManger->wcn_start_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_START_IFACE);
	snprintf(pWcndManger->wcn_stop_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_STOP_IFACE);
	snprintf(pWcndManger->wcn_download_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_DOWNLOAD_IFACE);
	snprintf(pWcndManger->wcn_image_file_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_IMAGE_NAME);
	snprintf(pWcndManger->wcn_atcmd_iface_name, WCND_MAX_IFACE_NAME_SIZE, "%s", WCN_ATCMD_IFACE);


	pWcndManger->wcn_image_file_size = WCN_IMAGE_SIZE;


	WCND_LOGD(" WCN ASSERT Interface: %s \n WCN WATCHDOG Interface: %s \n WCN LOOP Interface: %s \n WCN START Interface: %s \n"
		"WCN STOP Interface: %s \n WCN DOWNLAOD Interface: %s \n WCN IMAGE File: %s \n WCN ATCMD Interface: %s",  pWcndManger->wcn_assert_iface_name,
		pWcndManger->wcn_watchdog_iface_name, pWcndManger->wcn_loop_iface_name, pWcndManger->wcn_start_iface_name,
		pWcndManger->wcn_stop_iface_name, pWcndManger->wcn_download_iface_name, pWcndManger->wcn_image_file_name,
		pWcndManger->wcn_atcmd_iface_name);

	//To check if "persist.sys.sprd.wcnreset" is set or not. if not set it to be default "1"
	char value[PROPERTY_VALUE_MAX] = {'\0'};
	if(property_get(WCND_RESET_PROP_KEY, value, NULL) <= 0)
	{
		property_set(WCND_RESET_PROP_KEY, "1");
	}

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pWcndManger->selfcmd_sockets) == -1) {

		WCND_LOGE("%s: cannot create socketpair for self cmd socket", __FUNCTION__);
		return -1;
	}


	// to get the wcn modem state
	pWcndManger->is_wcn_modem_enabled = check_if_wcnmodem_enable();

	// to get build type
	property_get(BUILD_TYPE_PROP_KEY, value, USER_DEBUG_VERSION_STR);
	if(strstr(value, USER_DEBUG_VERSION_STR))
	{
		pWcndManger->is_in_userdebug = 1;
		WCND_LOGD("userdebug version: %s!!!", value);
	}


	wcnd_sm_init(pWcndManger);

	memcpy(pWcndManger->cp2_version_info, WCND_CP2_DEFAULT_CP2_VERSION_INFO, sizeof(WCND_CP2_DEFAULT_CP2_VERSION_INFO));


	//start engineer worker thread
	wcnd_worker_init(pWcndManger);

	pWcndManger->inited = 1;

	return 0;
}


////////////////////////////////////////////////////////////////////////////

/// below is the loop check related code /////

#ifdef LOOP_CHECK
/**
* Reset CP2 if loop check fail
*/
static void handle_cp2_loop_check_fail(WcndManager *pWcndManger)
{
	if(!pWcndManger)
	{
		WCND_LOGE("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		return;
	}

	WCND_LOGD("handle_cp2_loop_check_fail\n");

	//set the cp2 error flag, it is cleared when reset successfully
	pWcndManger->is_cp2_error = 1;

	char* rdbuffer = "CP2 LOOP CHECK FAIL";
	//char buffer[255];
	//int len;

	//memset(buffer, 0, sizeof(buffer));

	//reseting is going on just return
	if(pWcndManger->doing_reset)
		return;

#if 0
	pre_send_cp2_exception_notify();

	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_SELF_EVENT_CP2_ASSERT);

	//notify exception
	snprintf(buffer, 255, "%s %s", WCND_CP2_EXCEPTION_STRING, rdbuffer);
	wcnd_send_notify_to_client(pWcndManger, buffer, WCND_CLIENT_TYPE_NOTIFY);

	prepare_cp2_recovery(pWcndManger);

	//currently the reset is done when receive reset cmd from WcnManagerService.java
#endif

	notify_cp2_exception(pWcndManger, rdbuffer);


	WCND_LOGD("handle_cp2_loop_check_fail end!\n");

	return;

}

/**
*check cp2 loop dev interface in a interval of 5 seconds
* if fail, reset the cp2
*/
#define LOOP_CHECK_INTERVAL_MSECS (5000)
static void *cp2_loop_check_thread(void *arg)
{
	WcndManager *pWcndManger = (WcndManager *)arg;

	int count = 0;
	int is_loopcheck_fail = 0;

	if(!pWcndManger)
	{
		WCND_LOGD("%s: UNEXCPET NULL WcndManager", __FUNCTION__);
		exit(-1);
	}

	//First wait for 20 seconds for CP2 to be ready, and then start doing LOOP CHECK
	sleep(20);


	//special handle for the case that an assert/watchdog assert happens when system up
	//before WcnManagerService is ready. At this time need to notify assert again
	if(pWcndManger->is_cp2_error && !pWcndManger->doing_reset)
	{
		char value[PROPERTY_VALUE_MAX] = {'\0'};

		property_get(WCND_RESET_PROP_KEY, value, "0");
		int is_reset = atoi(value);
		if(is_reset)
		{
			WCND_LOGD("%s: CP2 assert/watchdog assert, and reset is enabled, but does not doing reset."
				"So notify loop fail again!!", __FUNCTION__);

			handle_cp2_loop_check_fail(pWcndManger);
			//wait 20 seconds for reset
			sleep(20);
		}
	}

	while(1)
	{
		usleep(LOOP_CHECK_INTERVAL_MSECS*1000);

		if(!pWcndManger->notify_enabled || (pWcndManger->state != WCND_STATE_CP2_STARTED))
			continue;

		//cp2 exception happens just continue for next poll
		if(pWcndManger->is_cp2_error)
		{
			WCND_LOGD("%s: CP2 exception happened and not reset success!!", __FUNCTION__);

			//wait for another 20 seconds for cp2 to be reset success
			//sleep(20);

			continue;
		}

		count = 2;
		while(count-- > 0)
		{
#ifdef USE_MARLIN
			if(is_cp2_alive_ok(pWcndManger, 0) < 0) //marlin cannot support select, so use non-block mode
#else
			if(is_cp2_alive_ok(pWcndManger, 1) < 0)
#endif
			{
				if(pWcndManger->is_cp2_error ||
					(pWcndManger->state != WCND_STATE_CP2_STARTED))//during loop checking, cp2 exception happens just continue
				{
					is_loopcheck_fail = 0;
					break;
				}

				is_loopcheck_fail = 1;
			}
			else
			{
				is_loopcheck_fail = 0;
				break;
			}
		}

		if(is_loopcheck_fail)
		{
			if(pWcndManger->is_in_userdebug) sleep(15); //add for waiting marlin watchdog to do some clean work, check Bug#440390

			WCND_LOGD("%s: loop check fail, going to reset cp2!!", __FUNCTION__);
			handle_cp2_loop_check_fail(pWcndManger);
			//wait 20 seconds for reset
			sleep(20);
		}

	}
}

/**
* Start thread to loop check if CP2 is alive.
* return -1 fail;
*/
static int start_cp2_loop_check(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

	if(pWcndManger->is_eng_mode_only) return 0;

	//if wcn modem is not enabled, just return
	if(!pWcndManger->is_wcn_modem_enabled) return 0;

	pthread_t thread_id;

	if (pthread_create(&thread_id, NULL, cp2_loop_check_thread, pWcndManger))
	{
		WCND_LOGE("start_cp2_loop_check: pthread_create (%s)", strerror(errno));
		return -1;
	}

	return 0;

}
#endif

/// loop check related code end /////


///////////////////////////////////////////////////////////////////////////

/**
* Start engineer service , such as for get CP2 log from PC.
* return -1 fail;
*/
static int start_engineer_service(WcndManager *pWcndManger)
{

	if(pWcndManger->is_eng_mode_only) return 0;

	if(!pWcndManger->is_wcn_modem_enabled) return 0;

	char prop[PROPERTY_VALUE_MAX] = {'\0'};
	WCND_LOGD("start engservice!");
	property_get(WCND_ENGCTRL_PROP_KEY,prop, "0");
	if(!strcmp(prop, "1")) {
		WCND_LOGD("persist.engpc.disable is true return  ");
		return 0;
	}

	property_set("ctl.start", "engservicewcn");//not used just now
	property_set("ctl.start", "engmodemclientwcn");//not used just now
	property_set("ctl.start", "engpcclientwcn");

	return 0;
}


///below is the related code for setting/getting of CP2 ///////////////////

/**
* Do some CP2 config, if it is a user version
*/
static int config_cp2_for_user_version(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

	//in user debug version just return
	if(pWcndManger->is_in_userdebug) return 0;

#ifndef USE_MARLIN
	//in user version, config CP2 to enter user mode
	WCND_LOGD("in user version, need to config CP2 to enter user mode!!!");
	wcnd_process_atcmd(-1, WCND_ATCMD_CP2_ENTER_USER, pWcndManger);
#endif

#if 0
	// Disable the CP2 log, if it is a user version
	WCND_LOGD("in user version, need to disable cp2 log!!!");
	wcnd_process_atcmd(-1, WCND_ATCMD_CP2_DISABLE_LOG, pWcndManger);
#endif

	return 0;
}



/**
* Store the CP2 Version info, used when system startup
*/
static int store_cp2_version_info(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

#ifdef WCND_CP2_POWER_ONOFF_ENABLE

	int count = 100;

	if(pWcndManger->is_eng_mode_only) return 0;

	//if not use our own wcn, just return
	if(!pWcndManger->is_wcn_modem_enabled) return 0;


	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_CMD_CP2_POWER_ON);

	//wait CP2 started, wait 10s at most
	while(count-- > 0)
	{
		if(pWcndManger->state == WCND_STATE_CP2_STARTED)
			break;

		usleep(100*1000);
	}

	if(pWcndManger->state != WCND_STATE_CP2_STARTED)
	{
		WCND_LOGE("%s: CP2 does not start successs, just return!!", __func__);
		return -1;
	}


	//wcnd_process_atcmd(-1, WCND_ATCMD_CP2_GET_VERSION, pWcndManger);
	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_SELF_CMD_CP2_VERSION);


	count = 100;
	//wait get cp2 version complete, wait 10s at most
	while(count-- > 0)
	{
		if(pWcndManger->store_cp2_versin_done)
			break;

		usleep(100*1000);
	}

	wcnd_send_selfcmd(pWcndManger, "wcn "WCND_CMD_CP2_POWER_OFF);

#endif

	return 0;
}


/**
* Config CP2 one time after CP2 has just started. (such as system boot up, CP2 recovery after reset)
* return 0 for success, -1 for fail.
*/
static int config_cp2_bootup(WcndManager *pWcndManger)
{
	if(!pWcndManger) return -1;

	if(pWcndManger->is_eng_mode_only) return 0;

	//if not use our own wcn, just return
	if(!pWcndManger->is_wcn_modem_enabled) return 0;

	// Do some CP2 config, if it is a user version
	config_cp2_for_user_version(pWcndManger);


	// Reset the cp2 log, since after power on cp2, it will reset to default
	if(pWcndManger->is_cp2log_opened)
	{
		wcnd_process_atcmd(-1, WCND_ATCMD_CP2_ENABLE_LOG, pWcndManger);
	}
	else
	{
		wcnd_process_atcmd(-1, WCND_ATCMD_CP2_DISABLE_LOG, pWcndManger);
	}

	return 0;
}

///the related code for setting/getting of CP2  end///////////////////


/**
* to switch to system user and set the cap
*/
static int os_process_init(void)
{
	struct __user_cap_header_struct header;
	struct __user_cap_data_struct cap;

	prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0);

	setuid(AID_SYSTEM);

	header.version = _LINUX_CAPABILITY_VERSION;
	header.pid = 0;
	cap.effective = cap.permitted =
		(1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_KILL);
	cap.inheritable = 0;
	capset(&header, &cap);


	//for debug
	gid_t list[64];
	int n, max;

	max = getgroups(64, list);
	if (max < 0) max = 0;

	WCND_LOGD("uid: %d,", getuid());

	WCND_LOGD("gid: %d,", getgid());
	if (max)
	{
		for(n = 0; n < max; n++)
			WCND_LOGD("group id %d: %d,", n, list[n]);
	}
	//for debug end

	return 0;
}


#ifdef WIFI_ENGINEER_ENABLE
//external cmd executer declare here.
extern WcnCmdExecuter wcn_eng_cmdexecuter;
#endif

int main(int argc, char *argv[])
{
	int autotest = 0;

	//parse arg first
	int c;
	int is_eng_only = 0;

	for (;;)
	{
		c = getopt(argc, argv, "G");
		if (c < 0) break;
		switch (c)
		{
			case 'G': //-G is engineer mode only
				is_eng_only = 1;
				break;
			default:
				break;
		}
	}

	if(!is_eng_only)
	{
		//check if in the engpc autotest mode
		autotest = check_kernel_cmdline(NULL);

		//if it is not an engineer mode only, then need to switch the user/group
		os_process_init();

		generate_wifi_mac();
		generate_bt_mac();
	}

	blockSigpipe();

	WcndManager *pWcndManger = wcnd_get_default_manager();
	if(!pWcndManger)
	{
		WCND_LOGE("wcnd_get_default_manager Fail!!!");
		return -1;
	}

	if(init(pWcndManger, is_eng_only) < 0)
	{
		WCND_LOGE("Init pWcnManager Fail!!!");
		return -1;
	}

	if(start_client_listener(pWcndManger) < 0)
	{
		WCND_LOGE("Start client listener Fail!!!");
		return -1;
	}

#ifdef CP2_WATCHER_ENABLE
	if(start_cp2_listener(pWcndManger) < 0)
	{
		WCND_LOGE("Start CP2 listener Fail!!!");
		return -1;
	}
#endif

	//Start engineer service , such as for get CP2 log from PC.
	pWcndManger->eng_autotest = autotest;
	if(!pWcndManger->eng_autotest)
	{
		start_engineer_service(pWcndManger);
	}

	//register builin cmd executer
	wcnd_register_cmdexecuter(pWcndManger, &wcn_cmdexecuter);

#ifdef WIFI_ENGINEER_ENABLE
	//register external cmd executer such eng mode
	wcnd_register_cmdexecuter(pWcndManger, &wcn_eng_cmdexecuter);
#endif


	//first check if CP2 alive, then config cp2 at bootup
	if(!pWcndManger->is_eng_mode_only && pWcndManger->state == WCND_STATE_CP2_STARTED
		&& pWcndManger->is_wcn_modem_enabled) //only our own wcn need to do this
	{
		int count = 2;
		int need_config_cp2 = 0;

		while(count-- > 0)
		{
			if(is_cp2_alive_ok(pWcndManger, 1) < 0)
			{
				if(pWcndManger->is_cp2_error ||
					(pWcndManger->state != WCND_STATE_CP2_STARTED))//during loop checking, cp2 exception happens just continue
				{
					break;
				}
			}
			else
			{
				need_config_cp2 = 1;
				break;
			}
		}

		if(need_config_cp2)
		{
			//config_cp2_bootup(pWcndManger);
			wcnd_send_selfcmd(pWcndManger, "wcn "WCND_SELF_CMD_CONFIG_CP2);

		}
		else
		{
			WCND_LOGE("loop_check Fail when startup: (pWcndManger->state:%d) !!!", pWcndManger->state);
		}
	}


#ifdef LOOP_CHECK
	if(start_cp2_loop_check(pWcndManger) < 0)
	{
		WCND_LOGE("Start CP2loop_check Fail!!!");
	}
#endif


	//get CP2 version and save it
	store_cp2_version_info(pWcndManger);

	//do nothing, just sleep
	do {
		sleep(1000);
	} while(1);

	return 0;
}


